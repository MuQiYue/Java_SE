### 多线程

#### 1 实现多线程

##### 1.1进程

进程：正在运行的程序
是系统进行资源分配和调用的独立单位
每个进程都有自己的内存空间和系统资源

##### 1.2 线程

线程：是进程中的单个顺序控制流，是一条执行路径
单线程：一个进程如果只有一条执行路径，则被称为单线程
多线程：一个进程如果有多条执行路径，则被称为多线程

##### 1.3 多线程的实现方式

方式一：继承Thread类
	定义一个类它继承Thread类
	在类中重写run()方法
	创建类的对象
	启动线程

执行线程方法：`void start()` 导致此线程开始执行; Java虚拟机调用此线程的run方法。
两个问题：
为什么要重写run方法？
	因为run方法是用来封装被线程执行的代码
run方法和start方法的区别？
	run方法封装线程执行的代码，直接调用，相当于普通方法调用
	start方法可以启动线程，然后由jvm调用此线程的run方法

##### 1.4 设置和获取线程名称

`String getName`
返回线程名称
`void setName(String name)`
将此线程的名称更改为等于参数name

可以去对象类中设置super方法去设置线程名称
`static Thread currenThread()`
返回对当前正在执行的线程对象的引用

##### 1.5 线程调度

线程有两种调度模型
	分时调度模型：所有线程轮流使用CPU的使用权，平均分配每个线程占用CPU的时间片
	抢占式调度模型：优先让优先级高的线程调用CPU，线程优先级相同，随机选择；优先	级高的线程占用CPU的时间更长

java使用的抢占式调度模型

Thread类中设置和获取线程优先级的方法
	`public final int getPriority()
`	
	返回此线程的优先级
	`public final void setPriority(int newPriority)
`	
	更改线程优先级
线程默认优先级是5，线程优先级的范围是1-10
优先级高仅代表该线程获取到CPU的时间片的几率高，要在你多次调用或者多次运行的时候，才会出现想要的结果

##### 1.6 线程控制

`static void sleep(long millis)`
是当前正在执行的线程停留(暂停执行)指定的毫秒数
`void join()`
等待这个线程死亡
`void setDaemon(boolean on)`
将此线程标记为守护线程，当运行的线程都是守护进程时，jvm将退出

##### 1.7 线程的生命周期

五种状态：
1、新建：创建线程对象(使用`start`方法到达就绪状态)
2、就绪：有执行资格，但没有执行权
3、运行：有执行资格有执行权(使用`sleep`方法或者其他堵塞式方法进入堵塞状态)或(`run`方法结束或`stop`方法进入死亡状态）
4、堵塞：没有执行资格没有执行权(`sleep`方法时间到或堵塞方式结束进入就绪状态)
5、死亡：线程死亡，变成垃圾

##### 1.8 多线程的使用方法

方式二：实现Runnable接口（建议使用此方法实现多继承）
	定义一个MyRunnable实现Runnable接口
	在MyRunnable类中重写run方法
	创建MyRunnable类的对象
	创建Thread类的对象，把MyRunnable对象作为构造方法的参数
	启动线程
Runnable没有继承Thread,所以要使用getName方法要先使用Thread.currentThread方法。

和继承Thread类相比，实现Runnable接口的好处
1、避免了Java单继承的局限性
2、适合多个相同程序的代码去处理同一个资源的情况，把线程和程序有效的分离，较好的体现了面对对象的设计思想

#### 2 线程同步

##### 2.1 线程安全问题

为什么会出现问题？
1、是否是多线程的环境
2、是否有共享数据
3、是否多条语句操控数据（修改这个问题）

如何解决多线程安全问题？
让程序更安全

如何实现解决？
把多条语句操控数据语句锁起来，让任意时刻只有一条线程执行即可
java提供了同步代码块的方式解决

##### 2.2 同步代码块

锁多条语句操作共享数据，可以提供同步代码块实现

格式：
synchronized(任意对象) {
		多条语句操作共享数据的代码
}

synchronized(任意对象)：相当于给代码加锁，任意对象就可以看成一把锁



任意对象可以使用object来声明（要把这个对象声明为成员对象）

同步代码块的好处：解决了多线程的安全问题
同步代码块的弊端：当线程较多的时候，每个线程都会去判断同步上的锁，无形的增加了程序的效率。

##### 2.3 同步方法

同步方法：将synchronized关键字添加到方法上
格式:
	修饰符 synchronized 返回值类型 方法名(方法参数) {}
同步方法锁的对象是this。

同步静态方法：将synchronized关键字添加到静态方法上
	格式:
		修饰符 static synchronized 返回值类型 方法名(方法参数) {}
同步方法锁的对象是 类名.class。

##### 2.4 线程安全的类

StringBuffer

* 线程安全，可变的字符序列

* 从JDK 5版本开始，这个类已经补充了一个设计用于单个线程的等效类， StringBuilder 	。 通常应优先使用StringBuilder类，因为它支持所有相同的操作，但速度更快，因为它	不执行同步。 

Vector(不会用到)

* 从Java 2平台v1.2开始，该类被改进以实现List接口，使其成为Java Collections ework的成员。与新的集合实现不同， Vector是同步的。 如果不需要线程安全实现，建议使用ArrayList代替Vector 。 

Hashtable(不会用到)

* 该类实现了一个哈希表，将键映射到值，任何非null对象都可以用作键或者值

* 从Java 2平台v1.2开始，该类被改进以实现Map接口，使其成为Java Collections Framework的成员。 与新的集合实现不同， Hashtable是同步的。 如果不需要线程安全实现，建议使用HashMap代替Hashtable 。

Collectios提供了把不安全的类变成安全的方法
static <T> List<T> synchronizedList(List<T> list) 
返回由指定列表支持的同步（线程安全）列表。  

##### 2.5 Lock锁

lock锁提供比synchronized方法更加广泛的锁定操作
lock中提供了获得锁和解放锁的方法

* void lock()	获得锁
* void unlock  解放锁

lock是接口不能直接实例化，这里采用它的实现类ReentrantLock来实例化
ReentrantLock的构造方法

* ReemtrantLock()		创建一个ReentrantLock的实例

一般不直接写进代码里而是使用try()finally()方法包裹，这样可以保证及时释放锁

#### 3 生产者消费者

##### 3.1 生产者消费者模式

生产者消费者模式时一个十分经典的多线程协作的模式，弄懂生产者消费者问题可以提高我们对多线程编程的理解

所谓的生产者消费者主要包括两种线程：

* 一类生产者线程用于生产数据
* 一类消费者线程用于消费数据

为了解耦生产者和消费者之间的关系，通常提供共享数据块，可以理解为一个共享仓库

为了体现生产和消费过程中的等待和唤醒，java提供了基类方法供我们使用，他们都在object类中。

* void wait()    导致线程等待，直到另一个线程调用该对象的notify方法或notifyAll方法
* void notify()  唤醒正在等待对象监视器的单个线程
* void notifyAll()  唤醒正在等待对象监视器的所个线程