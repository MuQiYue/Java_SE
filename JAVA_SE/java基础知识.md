### java基础知识

#### java代码的三个阶段

SOURCE: 编译时阶段

CLASS: 类对象阶段

RUNTIME: 运行时阶段

#### java方法

public static void name (int x, String y){ }

* public：访问控制权限，有四种：public(公共, 可以被所有其他类所访问)、private (私有,只能被自己访问和修改),protected (保护, 自身、子类及同一个包中类可以访问)，默认。

* static：状态修饰符，有两种：static和final

* viod：返回值类型，可以是任意的数据类型
* name：方法名
* int x，String y：形参

#### 方法调用

* 成员方法：要创建对象，才能使用

    需要先创建对象，才能调用其他类的成员方法

* 静态方法：直接使用类名调用

    不需要创建对象，直接使用类名创建就可以调用

* 构造方法：初始化类中的数据或变量

    创建对象，完成对象数据的初始化，如果类继承，首先会实例化父类的构造方法，然后逐一实例

#### 方法重载

主方法的调用，可以根据方法中的参数和参数数据类型进行选择需要的方法

满足的条件

* 多个方法在同一类中
* 多个方法具有相同的方法名
* 方法的参数、参数类型和参数数量不同

特点

* 重载方法和方法调用无关，调用方式参照标准格式
* 重载针对同一个类中方法的名称和参数识别，和返回值类型无关；换句话说，不能用返回值类型来判断两个方法是否重载

#### java对象

对象的描述：

* 万物皆对象，自然客观的事物都为对象，任何事物都可以封装成对象。

类的描述：

* 类是现实生活中一类具有相同属性和行为的事物的抽象

类的特点：

* 类是对象的数据类型
* 类具有相同属性和行为的一组对象的集合

对象的属性：对象具有各种特征，每个对象的每个属性都有特定的值（这个人的三维，体重，身高都可以是对象的属性）

对象的行为：对象能够执行的操作（人可以做什么？）

在计算机中，类是对象的抽象 也可以反过来说 对象是类的具体，类是对象的模板 ，对象是类的具体实例 。
类的属性：在类中通过成员变量来体现
类的行为：在类中使用成员方法类体现

#### 成员变量和局部变量

类中位置：

* 成员变量：类中方法外
* 局部变量：方法内或者方法申明上

内存中的位置：

* 成员变量：堆内存
* 局部变量：栈内存

生命周期不同：

* 成员变量：对象创建到死亡
* 局部变量：方法调用创建，调用完回收

初始值不同：

* 成员变量：有默认的初始值
* 局部变量：没有初始值，必须定义赋值

#### StringBuider类

概述：

StringBuider类是一个可变的字符串类，可以看做是一个容器

StringBuider和String的区别

* String类内容不可变
* StringBuider类内容可变

构造方法：

StringBuilder 对象名 = new StringBuilder();

常用方法：

* 对象名.append(数据)

    添加方法

* 对象名.reverse(数据)

    反转所有数据

#### 包

概述：

其实就是文件夹

格式：

pachage 包名;(如果是多级的包用 . 号分隔开 )

带包的java类编译和执行

* 手动建包：把包按以前的格式编译java文件手动建包
* 自动建包：javac -d xxx.java     执行：java 包名.xxx

#### 导包

概述：

是不同需要导入的包，而且需要到 把路径写全，为了简化带包的操作，java提供了导包的功能

格式：

inport 包名；

#### this关键字

this表示当前的类中的数据

构造方法：

可以用this()表示当前的构造方法，一个构造方法可以有多个this()方法，但必须有自己的出口否则会递归循环

用this关键字修饰的变量可以用来表示成员变量

#### super关键字

super表示对父类的数据

和this关键字的比较

* this关键字调用本类中的数据引用
* super关键字调用父类中的数据引用

#### 状态修饰符

##### final

final是最终的意思，可以修饰类、方法和变量

特点：

* 修饰方法：表明该方法是最终方法，不能重写
* 修饰类：表明该类是最终类，不能继承
* 修饰变量：表明改变量时最终变量不能再赋值

修饰局部变量

* 修饰基本类型的数据值不能改变
* 修饰引用类型的地制值不能改变，但地址的内容可以改变

##### static

static是静态的意思，同样可以修饰类、方法和变量

特点：

* 被类的所有对象共享
* 可以通过类名进行调用（当然也可以通过对象名）

访问特点

* 非静态成员方法
    * 能访问静态的成员变量
    * 能访问非静态的成员变量
    * 能访问静态的成员方法
    * 能访问非静态的成员方法
* 静态成员方法
    * 能访问静态的成员变量
    * 能访问静态的成员方法

总结：静态只能访问静态资源

#### 抽象类(abstract)

概述：更多体现的是对事物的抽象

java中一个没有方法体的方法应该定义为抽象方法，而类中如果有抽象方法就必须定义为抽象类

特点

* 抽象类和抽象方法必须使用abstract关键字修饰
* 抽象类中不一定有抽象方法，有抽象方法的类一定是抽象类
* 非抽象类继承抽象类是必须实现所有的抽象方法
* 抽象类不能实例化

成员特点：

* 成员变量：他可以是常量，也可以是变量
* 构造方法：有构造方法但不能实例化（用于子类访问数据的初始化)
* 成员方法：可以有抽象方法：限制子类必须完成某些动作，也可以成员方法，提要代码的复用性（继承保证）

#### 接口类(imterface)

概述：更多体现的是对行为的抽象

接口就是公共的规范标准，只要符合规范标准，大家都可以使用

特点：

* 接口使用imterface修饰
* 类实现接口用implement关键字
* 接口不能实例化：接口通过多态的方式，对类对象进行实例化
* 接口的实现类
    * 要么重写接口中的所有抽象方法
    * 要么是抽象类
* 成员特点：
    * 成员变量：只能是常量，默认使用修饰符：public static final
    * 构造方法：接口没有构造方法，因为接口主要是对行为进行抽象的，是没有具体存在
    * 成员方法：可以有静态方法和抽象方法：

类和类之间的关系：继承关系，只能单继承，但可以多重继承

类和接口的关系：实现关系，可以多继承，也可以多实现，还可以继承一个类的同时实现多个接口

接口和接口的关系：继承关系，可以是多继承也可以是单继承

##### 接口和抽象类之间的区别

* 成员区别：

    * 抽象类：常量、变量、构造方法、抽象方法、非抽象方法
    * 接口：常量，静态方法和抽象方法

* 关系区别：

    * 类和类：单继承
    * 类和接口：单实现和多实现
    * 接口和接口：单继承和多继承

* 设计理念区别：

    * 抽象类：对类的抽象，包括属性、行为
    * 接口：对行为的抽象，主要是行为

重点：

抽象类强调对事物的抽象，而接口是对行为的抽象

#### 形参和返回值

三种情况：

* 把普通类作为形参和返回值
    * 方法的形参是类名，其实调用这个对象
    * 方法的返回值是类名，其实就是返回这个对象
* 把抽象类名作为形参和返回值
    * 方法的形参是抽象类名，其实需要该抽象类的子类对象
    * 方法的返回值是抽象类名，其实返回值类型是该抽象类的子类对象

* 把接口名作为形参和返回值
    * 方法的形参是接口名，其实需要该接口的实现类对象
    * 方法的返回值类型是接口名，也同样是该接口的实现类对象

#### 内部类

概述：就是在类中定义一个类

格式：

public class 类名 {
		修饰符 class 类名 { 

​	}
}

访问特点：

* 内部类可以直接访问外部类的成员，包括私有
* 外部类要访问内部类的成员，必须创建对象

##### 成员内部类

成员内部类中，外界需要以下方法才能使用

* 格式：外部类名.内部类名 对象名 = 外部类对象.内部类对象；
* 范例：Outer.Inter oi = new Outer().new Inter();

以上的格式只有public修饰符才能调用

如果内部类使用private修饰则要先在外部类创建成员方法，方法中实例化内部类，然后通过实例化外部类再调用方法来调用外部类。

##### 局部内部类

概述：

局部内部类是在方法中定义的类，外界无法直接调用，需要在内部创建对象并使用。该类可以直接访问外部类的成员也可以访问方法体内部的局部变量

##### 匿名内部类

前提：存在一个类或接口，这里的类可以是具体类也可以是抽象类

格式：

类名 对象 = new 类名（new 类名或接口名(){
重写方法；
}

范例：

Inter i = new Inter(new leter(){
		public void show(){

​	}

});



#### java工具类

##### math类

概述：math类中包含基本的数字运算的方法

常用方法：

* static int abs(int a)		返回绝对值
* static double ceil(double a)    返回大于等于参数的最小double
* static double floor(double a)  返回小于等于参数的最大double
* static int round(float a)     按四舍五入返回最接近参数的int
* static int max(int a, int b)   返回两个int的较大值
* static int min(int a, int b)    返回两个int的较小值
* static double pow(double a，double b)    返回a的b次幂值
* static double random()      返回为double的正值[0.0, 1.0]

##### object类

概述：

任何类都直接或间接的继承(根类)

常用方法

* tostring ：返回对象的字符串表示形式，tostring方法返回一个“文本表示”次对象的字符串，建议所有子类重写此方法
* equals：指示某个对象是否对对等，默认比较地址，重写方法可以比较内容，自动生成

##### Arrays类

概述：

arrays中有用于操控数组的各种方法

常用方法：

* static String tostring (int[] a)		返回指定数组内容的字符串
* static void sort(int[] a)      按照数字顺序排列指定元素

##### 基本类型包装类

概述：

将基本数据类型封装成对象可以在对象中定义更多功能

基本数据类型				包装类

byte								Byte
short							  Short
int								   Integer
long								Long
float								Float
double  						 Double
char								Character
boolean						 Boolean

int和string的相互转换

* int转为string 
    * static string valueOf;
* String转为int
    * static int pareseInt(String s);
* string转为string数组
    * String[] split(String s);

自动装箱和拆箱

* 装箱：把基本数据类型转换为对应的包装类类型
* 拆箱：把包装类类型转换为对应的基本数据类型

注意：在使用包装类类型是，如果做操作，需要判断为null，只要是对象在使用前就必须判断不为null

##### Date类

概述：

代表一个特定的书剑，精确带毫秒

构造方法：

* public Date()   分配一个对象并初始化以便代表它被分配的时间
* public Date(long  date)   分配一个date对象，并初始化为表示标准基

常用方法：

* public 容 getTime()    获取的日期对象从1970年1月1日 00:00:00
* public void setTime(long time)   设置时间，给定的值为毫秒

##### Simple Date Format类

概述：

用于区域设置敏感的方式格式化和解析日期的具体类

常用的模式和字母关系如下

* y			年
* M          月
* d           日
* H           时
* m          分
* s            秒

构造方法：

* public Simple Date Format();
    * 构造一个simple date format,使用默认模式和日期
* public Simple Date Format(String pat)
    * 构造一个 public Simple Date Forma使用指定的模式和默认日期

成员方法：

* final String format(Date date)
    * 格式化：将日期格式转换为日期/String
* Date parse(string sou)
    * 解析：将给定的字符串转化为日期

#### Calendar类

概述：

Calendar是一个抽象类，为了设置和获取日历字段值

构造方法：Calendar rightnew = Calender.getInst();

常用方法：

* public intget(int field)    返回给定字段值
* public abstract void add(int field，int amount)    根据日历的规则，将指定的时间添加或减法给定的数值

* public abstract void set(int field,int amout)    设置当前的日历的年月日

#### 异常

概述：

就是程序出现了错误

体系：

* Throwable类是Java语言中所有错误和异常的超类。有两个子类Error和Exception。
* Error类表示严重问题，不需要处理
* Exception类是异常类，它表示程序本身可以处理的问题，有两种类型的子类RuntimeException类和非RuntimeException类。
* RuntimeException类：编译时不检查，出现问题，需要我们修改
* 非RuntimeException类：编译时就要处理，否则不通过编译

##### 异常处理（try...catch...)

格式：
try {
		可能会出现异常的代码；
} catch （异常类名.变量名）{
		异常处理的代码；
}

##### 异常抛开

概述：

当异常进行处理时，但不是我们所有的情况都有权限进行异常处理；当我们处理不了异常时，可以选择抛开异常。

格式：

throws 异常类名；
注意：这个格式是在方法或者类的后面的，谁调用谁处理

java有两种异常：编译时异常和运行时异常

* 编译时异常必须处理有两种方法：异常处理(try...catch...)和异常抛开(throws)。

* 运行时异常可以不处理，出现问题，需要我们修改代码



































